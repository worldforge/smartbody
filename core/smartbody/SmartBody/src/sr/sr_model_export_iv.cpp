/*************************************************************
Copyright (C) 2017 University of Southern California

This file is part of Smartbody.

Smartbody is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Smartbody is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Smartbody.  If not, see <http://www.gnu.org/licenses/>.

**************************************************************/

# include <sr/sr_model.h>

#include <fstream>
#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/convenience.hpp>
#include <sb/SBUtilities.h>

//# define SR_USE_TRACE1    // keyword tracking
//# include <sr/sr_trace.h>


static void wcolor ( SrColor c, SrOutput& o )
 {
   float f[4];
   c.get(f);
   o << f[0] << srspc << f[1] << srspc << f[2];
 }

bool SrModel::export_iv ( const char* file )
 {
   int i;
   SrOutput o ( fopen(file,"wt") );
   if ( !o.valid() ) return false;

   // ===== Header =================================
   o << "#VRML V1.0 ascii\n\n";
   o << "Separator {\n\n";
   o << "  Info { string \"Produced by SR Toolkit exporter v0.5, M. Kallmann 2003\" }\n\n";

   // ===== Hints ==================================
   o << "  ShapeHints {\n";
   if ( culling ) o << "   shapeType SOLID\n";
   o << "   vertexOrdering COUNTERCLOCKWISE\n";
   o << "   faceType CONVEX\n";
   o << "  }\n\n";
   
   //===== Materials ===============================
   if ( M.size()==1 )
    { o << "  Material {\n";
      o << "  diffuseColor "; wcolor(M[0].diffuse,o); o<<srnl;
      o << "  }\n\n";
    }
   else if ( M.size()>1 )
    { o << "  Material {\n";
      o << "  diffuseColor [\n";
      for ( i=0; i<M.size(); i++ )
       { o<<srtab;
         wcolor(M[i].diffuse,o);
         if ( i<M.size()-1 ) o<<",\n"; else o<<"]\n";
       }
      o << "  }\n";
      o << "  MaterialBinding { value PER_FACE_INDEXED }\n\n";
    }
   
   //===== Coordinates ===============================
   o << "  Coordinate3 { point [\n";
   for ( i=0; i<V.size(); i++ )
    { o << srtab << V[i];
      if ( i<V.size()-1 ) o<<",\n"; else o<<"]\n";
    }
   o << "  }\n\n";

   //===== Faces ===============================
   o << "  IndexedFaceSet { coordIndex [\n";

   for ( i=0; i<F.size(); i++ )
    { o << srtab << F[i][0] << ", " << F[i][1] << ", " << F[i][2] << ", -1";
      if ( i<F.size()-1 ) o<<",\n"; else o<<"]\n";
    }

   if ( M.size()>1 )
    { o << "    materialIndex [\n";
      for ( i=0; i<Fm.size(); i++ )
       { o << srtab << Fm[i];
         if ( i<Fm.size()-1 ) o<<",\n"; else o<<"]\n";
       }
    }

   o << "  }\n\n";

   //===== End ===============================

   o << "}\n\n";

   //SR_TRACE1("Ok!");
   return true;
 }

bool SrModel::export_obj ( const char* file, const char* mtlFile, const char* textureFile )
{
	boost::filesystem::path p(file); 
	boost::filesystem::path materialFile = p.parent_path();
	materialFile += "/";
	materialFile += mtlFile;

	int i;

	// write the material file
	std::ofstream mfile(boost::filesystem::complete(materialFile).string().c_str());
	if (mfile.is_open() != true)
	{
		SmartBody::util::log("Could not export file %s, problem opening that file for writing.", mtlFile);
		return false;
	}

	boost::filesystem::path t(textureFile); 

	mfile << "newmtl material_0" << srnl;
	mfile << "illum 4" << srnl;
	mfile << "Kd 0.00 0.00 0.00" << srnl;
	mfile << "Ka 0.20 0.20 0.20" << srnl;
	mfile << "Tf 1.00 1.00 1.00" << srnl;
	mfile << "map_Kd " << boost::filesystem::basename(t) << boost::filesystem::extension(t) << srnl;
	mfile << "Ni 1.00" << srnl;
	mfile << "Ks 1.00 1.00 1.00" << srnl;
	mfile << "Ns 0.00" << srnl;
	mfile.close();

	// write the .obj file
	std::ofstream o(file);
	if (o.is_open() != true)
	{
		SmartBody::util::log("Could not export file %s, problem opening that file for writing.", file);
		return false;
	}


	o << "# OBJ file generated by SmartBody\n\n";

	if ( name.len()>0 )
		o << "# " << name << srnl;

	o << "mtllib " << mtlFile << srnl;

   // save vertices (V)
   if ( V.size() ) 
   { 
      for ( i=0; i<V.size(); i++ )
		  o << "v " << V[i][0] << " " << V[i][1] << " " << V[i][2] << srnl;
   }
   
   // save normals (N)
	if ( N.size() )
	{ 
		for ( i=0; i<N.size(); i++ ) 
			o << "vn " << N[i][0] << " " << N[i][1] << " " << N[i][2]  << srnl;
	}


	o << "usemtl material_0" << srnl;
     // save textures (T)
	if ( T.size() )
	{ 
		for ( i=0; i < T.size(); i++ )
			o << "vt " << T[i].x << " " << T[i].y << srnl;
	} 
	
	
	// save faces (F)
	if ( F.size()  && Fn.size() && Fm.size())
	{ 
		for ( i=0; i < F.size(); i++ )
			o << "f " << (F[i][0] + 1) << "/" << (Ft[i][0] + 1) << "/" << (Fn[i][0]) << " " << (F[i][1] + 1) << "/" << (Ft[i][1] + 1) << "/" << (Fn[i][1]) << " " << (F[i][2] + 1)  << "/" << (Ft[i][2] + 1) << "/" << (Fn[i][2])<< srnl;
	}


	/*
   // save materials (M)
   if ( M.size() )
    { o << "<materials> " << M.size() << srnl;
      for ( i=0; i<M.size(); i++ ) o << M[i] << srnl;
      o << "</materials>\n\n";
    }

   // save materials per face (Fm)
   if ( Fm.size() )
    { o << "<materials_per_face> " << Fm.size() << srnl;
      for ( i=0; i<Fm.size(); i++ ) o << Fm[i] << srnl;
      o << "</materials_per_face>\n\n";
    }

   // save material names if there is one:
   bool savemtl=false;
   for ( i=0; i<mtlnames.size(); i++ )
    { if ( mtlnames[i][0] ) { savemtl=true; break; }
    }
   
   if ( savemtl )
    { o << "<material_names> " << srnl;
      for ( i=0; i<mtlnames.size(); i++ )
       { if ( mtlnames[i][0] ) o << i << srspc << mtlnames[i] << srnl;
       }
      o << "</material_names>\n\n";
    }
	*/

   return true;
}


//============================ EOF ===============================
